#ifndef __mogedMotionGraphEditor__
#define __mogedMotionGraphEditor__

/**
@file
Subclass of MotionGraphEditor, which is generated by wxFormBuilder.
*/

#include <list>
#include <vector>
#include <ostream>
#include "MogedFrames.h"
#include "Vector.hh"
#include "clip.hh"
#include "clipdb.hh"
#include "motiongraph.hh"
#include "entity.hh"

class AppContext;
class MGEdge;
class ClipDB;
class MotionGraph;
class Pose;
class ClipController;
class Vec3;
class Skeleton;
class Mesh;
class SkeletonWeights;
class CloudSampler;

/** Implementing MotionGraphEditor */
class mogedMotionGraphEditor : public MotionGraphEditor
{
	enum { TIMING_SAMPLES = 30 };                   // number of samples used for measuring how fast we're crunching numbers

	AppContext *m_ctx;                              // ...
	int m_current_state;                            // Current state of motion graph discovery we're in.

	typedef std::pair<int,int> ClipPair;            // index pairs for Clips we are going to compare 
	std::list< ClipPair > m_clipPairs;              // work list of clip comparisons
	
	std::vector<MotionGraphInfo> m_mg_infos;        // ??

	bool m_stepping;                                // True if we should pause after finding a transition.

    // Stores a potential transition found from comparing point clouds.
	struct TransitionCandidate {
		ClipHandle from_clip;           // ...           
		int from_frame;                 // frame in sample time
		float from_time;                // ??
		int from_insert_point;          // frame in clip time

		ClipHandle to_clip;             // ...
		int to_frame;                   // START of transition in sample time
		float to_time;                  // ??
		int to_insert_point;            // END of transition in clip time.

		Vec3 align_translation;         // translation required to align the to clip to the from clip
		float align_rotation;           // rotation required to align the to clip to the from clip
	};

    // ??
	struct PruneWorkItem {
    	PruneWorkItem(sqlite3_int64 anno, const char* name) :
    		anno(anno), name(name) {}

		sqlite3_int64 anno;
		std::string name;
	};

    // state data needed for finding transitions
	struct TransitionWorkingData
	{
		CloudSampler *sampler;                      // Sampler used to create point clouds for comparison.
		int num_clouds;                             // Total number of clouds.
		Vec3 **clouds;                              // Array of clouds, one cloud for each frame to compare
                                                    //  Clouds buffers contain #frames * #samples worth of positions. 
		int *cloud_lengths;                         // Number of frames for each cloud.

		float processed_per_second[TIMING_SAMPLES]; // For computing moving average of time taken to 
                                                    //  process point cloud differences
		int next_sample_idx;                        // next place to put a timing sample

		float *joint_weights;                       // Weights for each sample. TODO: consider computing this in the difference. Right now anything shorter than requested num_samples will have weird weighting

                                                    //   len = #Frames * #SamplesPerFrame
		float inv_sum_weights;                      // used for normalizing weights

		std::list< TransitionCandidate > transition_candidates;
		std::vector< ClipHandle > working_set;      // clips we are considering
        std::vector< sqlite3_int64 > initial_edges; // The initial edges corresponding to the set of clips in working_set
		std::vector< std::vector<int> > split_list; // split list holds the frame numbers where nodes will be
                                                    //  inserted into the original edge created for a clip. Indexed
                                                    //  in the same order as working_set
		int cur_split;


		std::vector< PruneWorkItem > graph_pruning_queue;   // ??
		int cur_prune_item;                         // ??

		AlgorithmMotionGraphHandle algo_graph;      // algorithm-supporting graph, used for pruning and building
                                                    //  the final graph
	
		TransitionWorkingData();
		~TransitionWorkingData() { clear(); }
		void clear();
	};
	
	struct TransitionFindingData
	{
		int from_idx;
		int to_idx;
		ClipHandle fromClip;
		ClipHandle toClip;
		int from_frame;
		int from_max;
		int to_frame;
		int to_max;

		float current_error_threshold;
		float* error_function_values;
		Vec3* alignment_translations;
		float* alignment_angles;
		std::vector<int> minima_indices;

		TransitionFindingData();
		~TransitionFindingData() { clear(); }
		void clear();		
	};

	struct Settings {
		int num_threads;
		float error_threshold;
		float point_cloud_rate;
		float transition_length; // in seconds
		float sample_rate; // fps to sample at
		float weight_falloff;

		int num_samples; // number of samples to gather given the above
		float sample_interval; // time per sample.
		Settings() { clear(); }
		void clear();
	};

    // Instances of the above structures, for organization.
	TransitionFindingData m_transition_finding;
	Settings m_settings;
	TransitionWorkingData m_working;

    ///// Private member functions
	void ReadSettings();
	void CreateWorkListAndStart();
	void CreateTransitionWorkListAndStart(const ClipDB* clips, std::ostream& out);
	bool ProcessNextTransition();
	void UpdateTiming(float num_per_sec);
	void PublishCloudData(bool do_align, Vec3_arg align_translation, float align_rotation, 
						  int from_offset = 0, int from_len = -1, int to_offset = 0, int to_len = -1);
	void InitJointWeights();

	void RestoreSavedSettings();
	void SaveSettings();
	void ExtractTransitionCandidates();
	void CreateBlendFromCandidate(std::ostream& out);
	bool ProcessSplits();
	bool PruneStep(std::ostream& out);
	void StartVerifyGraph(std::ostream& out);
	bool VerifyGraphStep(std::ostream& out);
    void PopulateInitialMotionGraph(MotionGraph* graph, const ClipDB* clips, std::ostream& out);

protected:
	// Handlers for MotionGraphEditor events.
	void OnIdle( wxIdleEvent& event );
	void OnPageChanged( wxListbookEvent& event );
	void OnPageChanging( wxListbookEvent& event );
	void OnScrollErrorThreshold( wxScrollEvent& event );
	void OnEditErrorThreshold( wxCommandEvent& event );
	void OnScrollCloudSampleRate( wxScrollEvent& event );
	void OnEditCloudSampleRate( wxCommandEvent& event );
	void OnScrollFalloff( wxScrollEvent& event );
	void OnEditFalloff( wxCommandEvent& event );
	void OnCreate( wxCommandEvent& event );
	void OnCancel( wxCommandEvent& event );
	void OnPause( wxCommandEvent& event );
	void OnNext( wxCommandEvent& event );
	void OnContinue( wxCommandEvent& event );

	void OnViewDistanceFunction( wxCommandEvent& event );
	void OnTransitionLengthChanged( wxCommandEvent& event ) ;
	void OnClose( wxCloseEvent& event ) ;

	void OnPruneGraph( wxCommandEvent& event ) ;
	void OnExportGraphViz( wxCommandEvent& event ) ;

public:
	/** Constructor */
	mogedMotionGraphEditor( wxWindow* parent, AppContext* ctx );
	~mogedMotionGraphEditor() ;
};

#endif // __mogedMotionGraphEditor__
